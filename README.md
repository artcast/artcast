Overview
========
This is the Artcast server: a special-purpose web server developed by the Artcast Project 
that is dedicated to the task of delivering time varying data for use in:

* Interactive artwork
* Kinetic sculpture
* Maker projects
* School assignments
* Cool hacks
* Whatever you dream up!

Artcast is designed to deliver data in a way that is simple, efficient, and low-latency.
Any device that can make HTTP requests can receive data from an Artcast server.

Design
======

There are three components in an Artcast system - Sources, Server, and Clients:

Sources
-------

An Artcast source is a program that generates time varying data for distribution by the
Artcast server.  Each datum generated by the source is a key-value pair where the key is
an arbitrary string, and the value is a JSON-encoded data structure.  These pairs are
broadcast to zero-or-more Artcast servers via multicast UDP, where they are distributed
to clients.  Thus, an Artcast source can be written using any language or
library that supports standard networking protocols.

Using JSON, sources can generate data of arbitrary complexity, although Artcasting favors
simplicity - you will want your data source to work well with a wide variety of devices,
including microcontrollers with minimal compute resources.

Sources may generate data at any time interval that is appropriate, from fractions of a
second to years; however, note that clients only receive datums at the time that they
are sent by a source, so your source should transmit datums at a reasonable rate - every
few minutes, for example - even if the data isn't changing that quickly.

Sources may also optionally "register" extra information about an Artcast that provide
additional details, including a human-readable description of the data, and its provenance.

To make creating new sources as easy as possible, the Artcast server is distributed with a Python
module with which a source can be written in just a few lines of code.

Server
------

The Artcast server is an HTTP server written in Python using the Tornado web framework.
The server receives datums broadcast from Artcast sources, distributing them
to waiting clients.  We chose to implement the server using Tornado because its asynchronous
design should be a good fit for the typical, highly-concurrent Artcast environment, where
large numbers of clients make long-running requests.

When a client makes an HTTP request to an Artcast server, the server doesn't respond
immediately with the current value for that Artcast.  Rather, the server holds the connection
open and only responds when a matching datum is received from a source - i.e. when the value *changes*.
This style of communication is widely known
as "long polling" or [Comet](http://en.wikipedia.org/wiki/Comet_(programming)).  We chose this
approach to pushing data from the server over more sophisticated technologies (multicasting, websockets)
because it can be easily implemented by even the most resource-constrained clients, avoids
firewall and network configuration issues, and is close to optimal in terms of network bandwidth.

Because Artcast servers receive datums via multicast UDP, it is easy to deploy multiple 
servers behind a load balancer and feed them with a single collection of sources.  This design
ensures that clients can receive consistently synchronized data even if their requests are routed
to multiple servers.

Clients
-------

An Artcast client is any device or program that can make HTTP requests to an Artcast server
and display / render / interpret the resulting values.  We envision that many Artcast clients will
be small microcontrollers such as Arduino, Raspberry Pi, or similar.  A client requests the next available
value from an Artcast source by performing an HTTP GET request
to the URL http://[server]/artcasts/[key] ... a response to the request is returned by the server as soon
as a datum that matches [key] is received from an Artcast source.  Once a client has
received the datum it can make a request for the next value.  Thus, Artcast clients use
long-polling to receive Artcast values as soon as they're available with a minimum of
latency and network traffic.

As with sources, clients can be written with any language or
framework, or use existing platforms such as web browsers.

Installation
============

To install the Artcast server, you will need the following:

* Python 2.6 or greater - <http://www.python.org>
* Tornado 2.4 web server - <http://www.tornadoweb.org>
* Python-Daemon - <http://pypi.python.org/pypi/python-daemon/>

Once you've installed the required modules, preferably using the package manager for your system, you
can obtain the server source code and run it:

    $ git clone git://github.com/artcast/artcast.git
    $ cd artcast/server
    $ python server.py

At this point, the server is running and waiting for requests on port 8888.  With a web browser that
supports Javascript, open <http://localhost:8888/artcasts/test/tick>.  You will see a plain web page that reads:

    Artcast: test/tick
    Value: 

Note that there isn't a value yet because there isn't a running Artcast source to provide values for the
"test/tick" key.  Leave the browser window open while you start the test source that's included with the
Artcast server.  Note that the included sources are written in Python, and have a dependency on a Python
module that handles the repetitive details of creating a source.  You'll need to set your
PYTHONPATH so the source scripts can find it.  In a separate shell window:

    $ cd artcast/sources
    $ export PYTHONPATH=../packages
    $ python test-sources.py

Now look at the browser window you opened.  You'll see that there's a value for the test/tick Artcast, and 
the value is changing.  The test/tick Artcast is simply a number that counts up from 0, changing once per second.
This isn't very interesting, but it's useful for testing and debugging.  Let's try a different Artcast ...
open <http://localhost:8888/artcasts/test/now>, and you will see the current GMT time, also changing once per second.

Production
----------

Although the default behaviors for the Artcast server are good for development and testing, running the
server in a real production environment will require changes, all of which are made via command-line
options when starting the server.  Use the --help option to display a list of options, including:

### Logging

By default, the Artcast server logs each client request in Apache / NCSA Extended Log Format to stderr.
You can redirect the log output to a file using the --access-log=[file] option.  When using --access-log,
Artcast will automatically limit the size of a log file to 10 MB, rotating log files up to a maximum of 100
files.  You can control these parameters with the --access-log-size=[bytes] and --access-log-count=[count] options.

Similarly, internal server errors are logged in unstructured format to stderr, unless you use the --error-log=[file],
--error-log-size=[bytes], and --error-log-count=[count] options.

### HTTP Port

As you saw earlier, Artcast server listens by default to port 8888, making it easy to run without root access.
To listen to a more common port, such as 80, use the --client-port=[port] option.

Of course, you will have to start Artcast server as root to listen to low-numbered ports under 1024.  Since
running a service as root is a serious security risk, you should use the --uid=[user id] option to instruct
Artcast server to drop its root privileges once the HTTP socket has been created.

### Init Scripts

Many platforms use init scripts to start services that should run in the background at startup.
To daemonize the Artcast server (run it in the background so init scripts don't block), pass the --daemonize
option at startup.

Further, many init scripts use "pidfiles" to keep track of running process ids so the process can be
queried and shutdown cleanly.  To automatically generate a pidfile at startup and delete it at shutdown,
use the --pidfile=[file path] option.

### UDP Ports

Artcast server listens for data from Artcast sources using a pair of multicast UDP groups, which are configurable
with the --data-group=[group], --data-port=[port], --register-group=[group], and --register-port=[port] options.

